---
title: "126 Data Project, Step 4"
date: "Sam Ream, Valeria Lopez, Skyler Yee"
output:
  pdf_document:
    latex_engine: xelatex
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
# knit options
knitr::opts_chunk$set(echo = F,
                      results = 'markup',
                      fig.width = 4,
                      fig.height = 3,
                      fig.align = 'center',
                      message = F,
                      warning = F)

# packages
library(tidyverse)
library(faraway)
library(RSQLite)
library(skimr)
library(GGally)
library(tidymodels)
library(leaps)
library(glmnet)
library(gridExtra)
```
```{r, echo=FALSE}
ball <- dbConnect(drv=RSQLite::SQLite(), dbname="../../data/database.sqlite")
```
```{r, echo =FALSE}
batting <- dbGetQuery(ball, "
                            SELECT
                            sum(ab) AS AT_BAT,
                            player_id,
                            sum(r) AS RUNS,
                            sum(hr) AS HOME_RUNS, 
                            sum(triple) AS TRIPLE,
                            sum(double) AS DOUBLE,
                            (sum(h) -  sum(hr) - sum(triple) - sum(double)) AS SINGLES,
                            sum(bb) AS WALKS,
                            sum(ibb) AS INT_WALKS,
                            sum(sb) AS STOLEN_BASES,
                            sum(hbp) AS HIT_BY_PITCH
                            
                            FROM
                            batting
                            where
                            year > 2000
                            group by
                            player_id
                            
                   ")
sumbat <- batting
batting <- subset(batting,batting[,1]>100)

set.seed(5)
batting <- sample_n(batting, 500, replace = FALSE)

players <- dbGetQuery(ball, "
                      
                      SELECT 
                      player_id,
                      (weight / POWER(height, 2)) *703 AS BMI,
                      bats as HAND
                      FROM
                      player
                      
                      ")




players <- subset(players, players[,2]>0)



for ( x in 1:17918)
{
  if(players[x,2] <= 18.5) {players[x,2] <- "U"} 
  else if(players[x,2] <= 24.9) {players[x,2] <- "H"}
  else if(players[x,2] <= 29.9) {players[x,2] <- "O"}
  else {players[x,2] <- "B"}
}

batting <-  merge(batting, players, by="player_id" )
```


```{r}
# x and y setup with current dataset
y <- batting$RUNS
x <- data.matrix(batting[, c('AT_BAT', 'HOME_RUNS', 'SINGLES', 'WALKS', 'DOUBLE', 'INT_WALKS', 'STOLEN_BASES', 'HIT_BY_PITCH')])
```


```{r echo = FALSE}
stat_model <- lm(RUNS~HOME_RUNS + SINGLES + WALKS + STOLEN_BASES, data = batting)
slm <- lm(RUNS~DOUBLE, data = batting)

```


# Introduction

Using the "History of Baseball" data set, we analyzed how our predictors (singles, doubles, triples, home runs, walks, intentional walks, hit by pitches, stolen bases, BMI, and batting hand) affected the runs scores by individual players. We sampled player statistics randomly from games played between 2000-2015, which allowed us to get an accurate representation of the population of all players who played between 2000 and 2015. Using both Ridge Regression and LASSO, we shrunk the size of some predictors to obtain estimates with smaller variance for higher precision. 

# Ridge Regression

```{r echo = FALSE}
ridge_model <- glmnet(x, y, alpha = 0)
```

### Optimal Lambda - Ridge Regression

```{r, fig.cap="The relationship between MSE and Log(lambda)"}
cv_model_ridge <- cv.glmnet(x, y, alpha = 0)

# find optimal lambda value that minimizes test MSE
best_lambda_r <- cv_model_ridge$lambda.min

# produce plot of test MSE by lambda value
plot(cv_model_ridge)

```

We found that the MSE was minimized when $\lambda$ is equal to:
```{r}
best_lambda_r
```


### Model Analysis



#### R-Squared Analysis
```{r}
#calculate R-squared
y_predicted <- predict(ridge_model, s = best_lambda_r, newx =x)

#SST and SSE
sst <- sum((y-mean(y))^2)
sse <- sum((y_predicted - y)^2)

rsq <- 1-(sse/sst)
rsq
```

When Lambda equals 24.53741, the R-Squared is 0.9914. This implies that the model explains approximately 99.14% of the variation in the response values..

#### Coefficient Analysis

```{r}
temp_ridge <- cv.glmnet(x, y, alpha = 0)
coef(temp_ridge)
```

# Lasso Regression

```{r echo = FALSE}
model <- glmnet(x, y, alpha = 1)
```

### Optimal Lambda - Lasso Regression

```{r, fig.cap="The relationship between MSE and Log(lambda)"}
cv_model <- cv.glmnet(x, y, alpha = 1)

# find optimal lambda value that minimizes test MSE
best_lambda <- cv_model$lambda.min

# produce plot of test MSE by lambda value
plot(cv_model)
```

We found that the MSE was minimized when $\lambda$ is equal to:
```{r}
best_lambda
```



### Model Analysis

#### R-Squared Analysis
```{r}
#calculate R-squared
y_predicted <- predict(model, s = best_lambda, newx =x)

#SST and SSE
sst <- sum((y-mean(y))^2)
sse <- sum((y_predicted - y)^2)

rsq <- 1-(sse/sst)
#rsq
```

When Lambda equals 0.3643727, the R-Squared is 0.9935687. This implies that the model explains approximately 99.36% of the variation in the response values.

#### Coefficient Analysis

```{r}
temp_lasso <- glmnet(x, y, alpha = 1, lambda = best_lambda)
coef(temp_ridge)
```

# Comparison of our Models

There is a plot below this

```{r, echo =FALSE}
batting <- dbGetQuery(ball, "
                            SELECT
                            sum(ab) AS AT_BAT,
                            player_id,
                            sum(r) AS RUNS,
                            sum(hr) AS HOME_RUNS, 
                            sum(triple) AS TRIPLE,
                            sum(double) AS DOUBLE,
                            (sum(h) -  sum(hr) - sum(triple) - sum(double)) AS SINGLES,
                            sum(bb) AS WALKS,
                            sum(ibb) AS INT_WALKS,
                            sum(sb) AS STOLEN_BASES,
                            sum(hbp) AS HIT_BY_PITCH
                            
                            FROM
                            batting
                            where
                            year > 2000
                            group by
                            player_id
                            
                   ")
sumbat <- batting
batting <- subset(batting,batting[,1]>100)

set.seed(4)
batting <- sample_n(batting, 500, replace = FALSE)

players <- dbGetQuery(ball, "
                      
                      SELECT 
                      player_id,
                      (weight / POWER(height, 2)) *703 AS BMI,
                      bats as HAND
                      FROM
                      player
                      
                      ")




players <- subset(players, players[,2]>0)



for ( x in 1:17918)
{
  if(players[x,2] <= 18.5) {players[x,2] <- "U"} 
  else if(players[x,2] <= 24.9) {players[x,2] <- "H"}
  else if(players[x,2] <= 29.9) {players[x,2] <- "O"}
  else {players[x,2] <- "B"}
}

batting <-  merge(batting, players, by="player_id" )

```
```{r}
x <- data.matrix(batting[, c('AT_BAT', 'HOME_RUNS', 'SINGLES', 'WALKS', 'DOUBLE', 'INT_WALKS', 'STOLEN_BASES', 'HIT_BY_PITCH')])
```

```{r}
ridge_model_y_predictions <- data.frame(Prediction = 1:500, Actual= 1:500)
ridge_model_y_predictions[,1] <- predict(ridge_model, s = best_lambda_r, newx = x)
ridge_model_y_predictions[,2] <- batting$RUNS

lasso_model_y_predictions <- data.frame(Prediction = 1:500, Actual = 1:500)
lasso_model_y_predictions[,1] <- predict(cv_model, s = best_lambda, newx = x)
lasso_model_y_predictions[,2] <- batting$RUNS


stat_model_y_predictions <- data.frame(Prediction = 1:500, Actual = 1:500)
stat_model_y_predictions[,1] <- predict(stat_model, newdata = batting)
stat_model_y_predictions[,2] <- batting$RUNS

slm_y_predictions <- data.frame(Prediction = 1:500, Actual = 1:500)
slm_y_predictions[,1] <- predict(slm, newdata = batting)
slm_y_predictions[,2] <- batting$RUNS
```

\newpage

```{r}
#Rsquare finder
#SLR
#MLR
#Ridge
#Lasso



```


```{r, fig.width=7,fig.height=2, fig.cap="A comparison of the Linear Models"}
ggplot() + 
  
  geom_point(aes(x=Prediction, y=Actual, color="SLM"), slm_y_predictions, size =0.5 )+
  geom_smooth(aes(x=Prediction, y=Actual, color="SLM"), slm_y_predictions, method = lm, fullrange =TRUE)+
  
  geom_point(aes(x=Prediction, y=Actual, color="MLR"), stat_model_y_predictions,size = 0.5) + 
  geom_smooth(aes(x=Prediction, y=Actual, color="MLR"), stat_model_y_predictions, method = lm, fullrange =TRUE)+
  
  geom_point(aes(x=Prediction, y=Actual, color="Ridge Model"), ridge_model_y_predictions, size =0.5)+
  geom_smooth(aes(x=Prediction, y=Actual, color="Ridge Model"), ridge_model_y_predictions, method = lm, fullrange =TRUE)+
  
  geom_point(aes(x=Prediction, y=Actual, color="Lasso Model"), lasso_model_y_predictions, size =0.5 )+
  geom_smooth(aes(x=Prediction, y=Actual, color="Lasso Model"), lasso_model_y_predictions, method = lm, fullrange =TRUE)+
  

  
  labs(color = "Model")
```

|       Model Type          |  $R^2$ | MSE |
|:-----------------|----:|---:|
|SLR              | `r 1-(sum((slm_y_predictions[,1]-slm_y_predictions[,2])^2)/sum((slm_y_predictions[,2]-sum(slm_y_predictions[,2])/500)^2))`|   `r (1/500) * sum((slm_y_predictions[,2]-slm_y_predictions[,1])^2)`|
|MLR              | `r 1-(sum((stat_model_y_predictions[,1]-stat_model_y_predictions[,2])^2)/sum((stat_model_y_predictions[,2]-sum(stat_model_y_predictions[,2])/500)^2))`|   `r (1/500) * sum((stat_model_y_predictions[,2]-stat_model_y_predictions[,1])^2)`|
|Ridge Regression | `r 1-(sum((ridge_model_y_predictions[,1]-ridge_model_y_predictions[,2])^2)/sum((ridge_model_y_predictions[,2]-sum(ridge_model_y_predictions[,2])/500)^2))`|   `r (1/500) * sum((ridge_model_y_predictions[,2]-ridge_model_y_predictions[,1])^2)`|
|Lasso Regression | `r 1-(sum((lasso_model_y_predictions[,1]-lasso_model_y_predictions[,2])^2)/sum((lasso_model_y_predictions[,2]-sum(lasso_model_y_predictions[,2])/500)^2))`|   `r (1/500) * sum((lasso_model_y_predictions[,2]-lasso_model_y_predictions[,1])^2)`||

There is a plot above this

# Investigation - Principle Component Analysis

Waiting for sam's work

# Conclusion

GDRIVE - PSTAT126_PROJ_STEP_4_CONC

(Everything is still temp above, will finalize tomorrow well before 3pm)

